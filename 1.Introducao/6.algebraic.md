### Indice

- [6 Tipos algebricos](#6-tipos-algebricos)
  - [6.1 Listas](#61-listas)
  - [6.1.1 Funções úteis e o módulo Data.List](#611-funções-úteis-e-o-módulo-datalist)
  - [6.2 Type variables](#62-type-variables)
  - [6.2 Type Constructors e Data Constructors](#62-type-constructors-e-data-constructors)

# 6 Tipos algebricos

Agora está na hora de criarmos os nossos próprios tipos. Para começar, precisamos entender o porquê de tipos serem "algebricos". Em resumo, uma algebra é constituida de um conjunto e operações de soma e produto, ou seja, podemos podemos fazer "fórmulas" com nossos tipos e construir uma fundação sólida a partir de "somas" e "produtos". Para isso, vamos tentar dar uma olhada em alguns tipos:

- `Void`: Até agora não utilizamos esse tipo e provavelmente não iremos usar tão cedo! esse tipo não tem nenhum habitante e então não tem como criar algo que tenha esse tipo. Por não ter nenhum habitante vamos falar que ele representa o `0`.

- `Unit` ou `()`: Usamos esse tipo no módulo de IO e como foi dito, só há uma forma de construi-lo é usando `()`, ou seja, só há `1` habitante.

- `Bool`: O tipo de booleano tem dois construtores, o `True` e o `False`. Podemos descrever esse tipo como `True | False` com o simbolo de pipe (`|`) representando "um ou outro". No final, podemos dizer que há `1+1` formas de representar esse tipo.

- `(Int, Bool)`: A tupla de dois elementos com `Int` e `Bool` pode ser instanciada de infinitas maneiras já que `Int` tem infinitos construtores. Porém, se representarmos a quantidade de construtores de `Int` como `a` podemos criar uma formula para esse tipo: `a * 2`. A multiplicação aparece pela quantidade de alternativas que podemos fazer, para cada `True` e `False`, podemos repetir 1 número.

Vamos tentar criar nosso proprio tipo Bool só que com nome `MasUe` que vai ter dois construtores, `Sim` e `Nao`.

```idris
data MasUe = Sim | Nao
```

Bem simples certo? Agora vamos criar uma função que irá negar o `MasUe` que irá utilizar de pattern matching para verificar qual é o valor e então retornar um valor que depende desse pattern matching.

```idris
nao : Masue -> Masue 
nao Sim = Nao
nao Nao = Sim
```

Se utilizarmos essa função no REPL:

```idris
> nao Sim
Nao
```

Também podemos definir nossas proprias tuplas. Dados que estão juntos não precisam estar separados por um `|` como em:

```idris
data Produto = FazerProduto Int Bool
```

Nesse exemplo, definimos um tipo chamado `Tupla` que tem como construtor o `FazerTupla` que carrega dois dados dentro de si, Int e Bool. No exemplo abaixo, construimos tipo `Tupla` através do `FazerTupla`.

```idris
minhaTupla : Produto
minhaTupla = FazerProduto 123 True
```

Também da para juntar os 2 conceitos em um só! Como por exemplo em:

```idris
data NumeroOuBool = Numero Int | Boleano Bool

umDosDois : NumeroOuBool
umDosDois = Numero 10

outroDosDois : NumeroOuBool
outroDosDois = Boleano True
```

E com pattern matching, podemos retirar os valores de dentro desse ultimo tipo.

```idris
removerNumeroOu : NumeroOuBool -> Int 
removerNumeroOu (Numero n)  ou = n 
removerNumeroOu (Boleano b) ou = ou
```

E executando essa função:
```
> removerNumeroOu (Numero 24) 1000
24

> removerNumeroOu (Boleano True) 1000
1000
```

## 6.1 Listas

Vamos começar com um exemplo simples: Imagine que ao invés de guardar dois ou três números numa variável, você necessita de guardar vários. Nesse caso, nós podemos utilizar o tipo `List`, porém, usar esse tipo requer um tipo extra que será passado junto com ele para especificar o tipo das coisas que estão dentro da lista como por exemplo, uma lista de String:

```idris
minhaListaDeCompras : List String
minhaListaDeCompras = 
  [ "10x Pudim",
    "2x Alface",
    "32x Doritos",
    "2x Meias de programador" 
  ]
```

Podemos utilizar também com tuplas como em:

```idris
minhaListaDeCompras List (Int, String)
minhaListaDeCompras = [ (10, "Pudim"), (2, "Alface"), (32, "Doritos"), (7, "Meias de programador") ]
```

Esse modo de escrever listas (`[... , ..., ...]`) é considerado um *açúcar sintático* já que, de fato, ele vira uma sintáxe menos agradável mas que significa a mesma coisa. Nessa sintáxe, representamos que um valor está sendo acrescentado no inicio de uma lista utilizando o operador `::` e que `Nil` é uma lista vazia. 

```idris
minhaLista : List Int 
minhaLista = 1 :: 2 :: Nil
```

<p align="center">
  <img src="https://i.imgur.com/k1gwh3I.png" width="800px">
</p>


Para retirar coisas dessa lista podemos utilizar o pattern matching (checagem de padrões) tanto quanto no `case` quanto na função tal como:

```idris
-- Recebe uma lista de String e uma String e retorna uma String
retirarPrimeiroOu : List String -> String -> String 
retirarPrimeiroOu lista ou =
  case lista of 
    (primeiro :: resto) => primeiro
    [] => ou 
```

Ou de formato equivalente, utilizando o pattern matching dentro dos argumentos da função:

```idris
-- Recebe uma lista de String e uma String e retorna uma String
retirarPrimeiroOu : List String -> String -> String 
retirarPrimeiroOu (primeiro :: resto) ou = primeiro
retirarPrimeiroOu [] ou = ou
```

Nesse exemplo, caso a lista esteja no padrão `primeiro :: resto`, ou seja, tenha pelo menos um elemento, ele irá retornar o `primeiro`. Caso a lista esteja vazia (no padrão `[]`), a função irá retornar `ou` que é o segundo argumento que mandamos.

<p align="center">
  <img src="https://i.imgur.com/bv3wj0A.png" width="800px">
</p>


Vamos executar para ver o que acontece:
```idris
> retirarPrimeiroOu ["Banana", "Uva"] "Não tem nada"
"Banana"
```

Em caso de lista vazia ele retorna o `ou`.

```idris
> retirarPrimeiroOu [] "Não tem nada"
"Não tem nada"
```

Para adicionar coisas dentro de uma lista podemos utilizar novamente o operador `::` como em:

```idris
-- Recebe uma lista de String e uma String e retorna uma Lista de String
adicionar : List String -> String -> List String 
adicionar lista valor = valor :: lista 
```

E se executarmos:

```idris
> adicionar ["Pudim"] "Ameixa"
["Ameixa", "Pudim"]
```

Uma função muito útil para casos que em temos duas listas é a função `concat` com o operador `++`. Podemos utilizar essa função para juntar duas listas facilmente como em:

```idris
Main> [1,2,3] ++ [4,5]
[1, 2, 3, 4, 5]
```

E com isso já conseguimos implementar a função `reverse` que inverte uma lista. Não se preocupe se não entender, tente escrever no papel passo a passo das coisas que acontece em toda de execução já que é uma função um pouco mais difícil de compreender no primeiro momento.

```idris
inverter : List Int -> List Int 
inverter []        = [] -- o inverso de uma lista vazia é uma lista vazia
inverter (x :: xs) = (inverter xs) ++ [x] -- soma o primeiro elemento no inverso do resto da lista
```

Nesse exemplo, caso o primeiro argumento seja uma lista vazia, nós podemos apenas retornar uma lista vazia. Caso o argumento tenha o padrão `x::xs` como em `[1,2,3]`, então nós podemos inverter o resto da lista e adicionar no final uma lista de `x`. 

Vamos ver os passos para `[1,2,3]`
  - Começamos com `[1,2,3]` que vai ao padrão `x :: xs` resultando em 
    `x = 1`
    `xs = [2,3]`
    Com isso, retornamos 
    `(inverter [2,3]) ++ [1]`
  - Agora, seguindo o passo da recursão, temos `[2,3]` que também se encaixa no padrão `x :: xs` fazendo com que:
    `x = 2`
    `x = [3]`
    Com isso retornando
    `(inverter [3])  ++ [2]`
  - Esse é o penúltimo passo, temos `[3]` que também se encaixa no padrão `x::xs` fazendo com que
    `x = 3`
    `xs = []`
    Com isso retornando
    `(inverter []) ++ [3]`
  - E agora finalmente chegamos no passo onde temos `[]` que simplesmente irá retornar `[]` e então podemos voltar na recursão:
    - Voltando os passos:
      `(inverter [2,3]) ++ [1]`
      `((inverter [3])  ++ [2]) ++ [1]`
      `(((inverter []) ++ [3])  ++ [2]) ++ [1]`
      `(([] ++ [3])  ++ [2]) ++ [1]`
      `([3]  ++ [2]) ++ [1]`
      `[3, 2]) ++ [1]`
      `[3, 2, 1]`

## 6.1.1 Funções úteis e o módulo Data.List

Módulos são conjuntos de funções e tipos que outra pessoa escreveu para facilitar nosso trabalho. Para utilizar o módulo `Data.List` (que irá nos ajudar com várias coisas envolvendo listas), devemos importa-lo em nosso código como em:

```idris
import Data.List 

main : IO ()
main = do
  let quantidades = [10,2,2]
  let nomes = ["Pudins", "Peixes", "Meias de programador"]
  print (zip quantidades nomes)
```

O tipo da função `zip` é `List a -> List b -> List (a,b)`. Isso significa que ele vai receber uma lista de um tipo `a`, que no nosso caso é Int, e uma lista de tipo `b`, que no nosso caso é String, e vai retornar uma lista de tuplas.

O resultado ao rodar esse código:
```idris
[(10, "Pudins"),(2, "Peixes"),(2, "Meias de programador")]
```

## 6.2 Type variables

Imagina que dor seria se para cada tipo de lista que tivermos em nosso programa, tivessemos que escrever uma função especifica que faz a mesma coisa em todas como, por exemplo:

```idris
adicionarListaTexto : List String -> String -> List String
adicionarListaTexto lista novo = novo :: lista

adicionarListaNumero : List Int -> Int -> List Int 
adicionarListaNumero lista novo = novo :: lista

adicionarListaTupla : List (String, Int) -> (String, Int) -> List (String, Int)
adicionarListaTupla lista novo = novo :: lista
```

Para evitar isso, podemos usar **variáveis de tipos**. As variáveis de tipos nos ajudam a descrever funções que aceitam ou retornam "qualquer tipo", porém, com restrições. Nós podemos chamar esse tipo de função de polimórfica (contém varias formas), porém apesar de poder assumir varios tipos diferentes, não podemos usar funções restritas a um tipo (como por exemplo a soma que é restrita para números) com "qualquer tipo", já que isso resultaria em um problema ou comportamento indefinido. Porém, no nosso exemplo acima, podemos usar essas variáveis de tipo para abstrair que precisamos de uma lista de qualquer tipo, aceitamos uma unidade desse tipo e retornamos uma lista desse mesmo tipo. Para isso, usamos um tipo com nome composto de letras minúsculas como por exemplo `a`.

```idris
-- Note que `a` é uma variável de tipo, ou seja, pode ser qualquer tipo 
-- desde que todos os `a` na expressão sejam iguais! 
-- Já a função `adicionarNaLista` é considerada polimorfica já que pode assumir varios tipos.

adicionarNaLista : List a -> a -> List a 
adicionarNaLista lista novo = novo :: lista
```

Vamos testar essa função!

```idris
> adicionarNaLista [1,2,3] 0
[0,3,2,1]
```
```idris
> adicionarNaLista [(1, "Leite"), (2, "Dakimakura do Jimin")] (400, "Livro do Edwin Brady sobre Idris")
[(400, "Livro do Edwin Brady sobre Idris"), (1, "Leite"), (2, "Dakimakura do Jimin")]
```

Funciona tanto para tuplas, quanto para Ints. Porém se tentarmos fazer algo inválido como:

```idris
> adicionarNaLista ["Killua"] 3 

While processing right hand side of lero. Can't find an implementation for Num String

```

Idris não consegue processar que o tipo `a`, no primeiro argumento da função adicionarNaLista, é `Int`. Já que se aconteceu um "unificação" entre `List String` e `List a` resultando em `a = String`, não tem como `a` ser Int no segundo argumento.

Podemos utilizar as duas construções algébricas junto com listas para modelar dados mais complexos. Vamos começar por um exemplo de uma loja de donuts que tem que receber um pedido de um produto com o nome de quem pediu e devolver uma estrutura falando quem compro isso. No bloco de código a seguir, irei criar dois tipos que vão servir para representar os produtos que a loja venda e o sabor dos donuts.

```idris
data Sabor   = Chocolate | Morango 
data Produto = Donut Sabor | Caixa (List Produto)
```

Na primeira linha nós declaramos um tipo que representa o sabor de um donut, nesse caso ele é útil para a segunda linha que é usado no construtor de dado `Donut`. Na segunda linha, como dito, há um construtor de dado que se chama `Donut` e recebe um `Sabor` para constitutir o tipo `Produto` e um outro construtor chamado `Caixa` que recebe uma caixa de produtos, ou seja, podemos receber uma caixa com duas caixas de caixas de Donuts. 

Vamos ver quais tipos são válidos:
- `Donut` não é um `Produto` e sim um `Sabor -> Produto` já que falta especificar o `Sabor`
- `Donut Morango` é um habitante do tipo `Produto`
- `Donut Chocolate` é um habitante do tipo `Produto`
- `[Donut Chocolate, Donut Morango]` é do tipo `List Produto`
- `Caixa [Donut Chocolate, Donut Morango]` é do tipo `Produto` já que `Caixa` de `List Produto` para virar `Produto`
- `Caixa [Caixa [], Caixa [Donut Chocolate]]` também é um `Produto` já que `Caixa []` também é um `Produto`.

Obs: no próximo tópico, usaremos os dois mesmos tipos para representar o pedido e uma "nota fiscal".

## 6.2 Type Constructors e Data Constructors

Uma coisa que pode parecer incerta para você é do porquê que só `List` tem que vir acompanhado de outro tipo e os outros não. Até agora, os tipos que nós vimos são muitas vezes simples e que não precisam de outros tipos para existir, já o `List` é considerado um *type constructor* já que para construir o tipo concreto, nós precisamos especificar um segundo tipo. Podemos considerar o `List` como uma função que retorna um tipo ao receber um tipo. Nós vimos anteriormente que listas tem o construtor de dado `::` que junta um elemento inicial com uma outra lista como em `1 :: []` (que coloca 1 numa lista vazia). 
