### Indice

- [4. Brincando com IO](#4-brincando-com-io)
  - [4.1 PrintLn e PutStrLn](#41-println-e-putstrln)
  - [5.2 Nota√ß√£o `do`](#52-nota√ß√£o-do)
  - [5.3 getLine](#53-getline)
  - [5.4 Fun√ß√µes e pure](#54-fun√ß√µes-e-pure)

# 4. Brincando com IO

Nesta parte do curso, para conseguirmos fazer as coisas serem mais f√°ceis de "brincar", n√≥s iremos aprender sobre opera√ß√µes de IO (entrada/sa√≠da de dados). Como dito no primeiro cap√≠tulo, Idris2 √© uma linguagem de programa√ß√£o funcional *pura*. A *pureza* da linguagem se deve ao fato que nenhuma fun√ß√£o produz *efeitos colaterais* como, por exemplo, uma modifica√ß√£o de uma vari√°vel externa √† fun√ß√£o ou, ler um arquivo dentro de uma fun√ß√£o que recebe `Int` e retorna `Int`. 

Ent√£o, como Idris2 consegue fazer coisas √∫teis como colocar algo na tela ou se conectar a um banco de dados? Para isso n√≥s usamos um construtor de tipo chamado `IO` que ir√° nos auxiliar a falar que na fun√ß√£o podemos causar efeitos colaterais, com um truque bem bizarro. Na estrutura desse dado de tipo `IO`, implicitamente, h√° um dado que representa o **Mundo** todo e quando colocarmos algo na tela, o **Mundo** √© recriado, contudo agora com essa coisa na tela. Ent√£o, com esse truque bizarro, n√≥s conseguimos manter o mundo todo dentro de uma fun√ß√£o!

<p align="center">
  <img src="https://i.imgur.com/lM70scH.png" width="400px">
</p>


```idris
main : IO ()
main = putStrLn "Oi, Mundo!"
```

Repare que a fun√ß√£o `main` tem tipo `IO ()`. O tipo `IO ()` √© composto de duas partes, a primeira √© o construtor de tipo `IO` que revela que a fun√ß√£o vai causar efeitos colaterais e a segunda √© o tipo `()`. O tipo `()` (tamb√©m chamado `Unit`) √© um tipo com um √∫nico construtor que √© o `()`, ou seja, `() : ()`! Esse tipo √© √∫til para representar que o retorno de uma fun√ß√£o √© in√∫til como na fun√ß√£o `printLn` que coloca um dado na tela e ent√£o n√£o deve retornar nada. Por√©m, como toda fun√ß√£o retorna algo em Idris, n√≥s temos que retornar algo e esse algo √© `()`.

<p align="center">
  <img src="https://i.imgur.com/ALdBG5T.png" width="600px">
</p>


Um exemplo de fun√ß√£o legal que usa `IO ()` √© a fun√ß√£o `putStrLn`.
```idris
-- recebe uma String e retorna um `IO ()`, ou seja, causa efeito colateral e retorna ().
putStrLn : String -> IO ()
```

Exemplo da fun√ß√£o `main` que sempre vai ter o tipo `IO ()`, ou seja, no final, o programa sempre causa efeitos colaterais e n√£o retorna "nada". Por√©m, a separa√ß√£o entre fun√ß√µes que causam efeitos colaterais com fun√ß√µes que n√£o causam √© vis√≠vel diferente de outras linguagens.


## 4.1 PrintLn e PutStrLn 

Quando temos dados do tipo `String` (texto), podemos imprimi-los na tela usando a fun√ß√£o `putStrLn`. Caso o nosso tipo do dado n√£o seja `String`, n√≥s podemos usar outra fun√ß√£o que ir√° **transformar** em `String` para n√≥s antes de colocar na tela que se chama `printLn`. Caso voc√™ tente colocar uma `String` como argumento de um `printLn`, voc√™ ver√° que o que ir√° aparecer na tela √© o dado entre aspas, sendo basicamente o que acontece quando voc√™ transforma uma `String` em uma `String`. 

Obs: No terminal, o :exec roda fun√ß√µes de IO para n√≥s.

Usando `putStrLn` com o tipo `String`:
```idris
> :exec putStrLn "A: Por que n√£o tentamos escrever um poema?"
A: Por que n√£o tentamos escrever um poema?
```

Usando `printLn` com tipo `String`:
```idris
> :exec printLn "A: Por que n√£o tentamos escrever um poema?"
"A: Por que n√£o tentamos escrever um poema?"
```

Usando `putStrLn` com o tipo `Int` resulta em um erro j√° que a fun√ß√£o s√≥ aceita `String`:
```idris
> :exec putStrLn 3
Error: Can't find an implementation for Num String.

(Interactive):1:16--1:17
 1 | :exec putStrLn 3
                    ^
```

Usando `printLn` com o tipo `Int`
```idris
> :exec printLn 3
3
```

## 5.2 Nota√ß√£o `do`

Podemos fazer opera√ß√µes que resultam em `IO` em sequ√™ncia utilizando a nota√ß√£o `do` na seguinte forma: 

```idris
-- come√ßamos a fun√ß√£o com um `do`
main : IO ()
main = do 
  putStrLn "30 Minutos depois"
  putStrLn "A - O poema est√° pronto?"
  putStrLn "B - Sim..."
  putStrLn "E ent√£o, 'A' pega o poema rapidamente e come√ßa a ler. E depois de ler, diz em voz baixa:"
  putStrLn "A - Me desculpa por ter nascido üò≠"
```

O nome desses personagens n√£o √© muito atraente. Para poder ser f√°cil modificar as coisas,  podemos utilizar a *interpola√ß√£o* para inserir dados em uma `String`. Para isso usamos a sintaxe `\{}` dentro de uma string e ent√£o inserimos um dado. Exemplo:

```idris
let nome = "Beto" in 
"\{nome}: Oi"
```

Ou no REPL:
```idris
> let nome = "Beto" in "\{nome}: Oi"
"Beto: Oi"
```

E no caso da nossa sequ√™ncia ficaria:

```idris
-- Note que se estivermos utilizando a nota√ß√£o do, n√≥s 
-- n√£o precisamos utilizar `in` ap√≥s o `let` por que se 
-- n√£o acabariamos tendo que colocar `in` e `do` para 
-- continuar a express√£o.
main : IO ()
main = do 
  let persoA = "Maka"
  let persoB = "Crona"
  putStrLn "30 Minutos depois"
  putStrLn "\{persoA} - O poema est√° pronto?"
  putStrLn "\{persoB} - Sim..."
  putStrLn "E ent√£o, \{persoA} pega o poema rapidamente e come√ßa a ler. E depois de ler, diz em voz baixa:"
  putStrLn "\{persoA} - Me desculpa por ter nascido üò≠"
```

Obs: O `ln` no final das fun√ß√µes de `putStr` e `print` faz com que, ap√≥s colocar o texto na tela, a fun√ß√£o coloque uma quebra de linha. 

## 5.3 getLine

A fun√ß√£o `getLine` √© util para pegar dados que o usu√°rio digitar no terminal. Por√©m, al√©m de aprendermos essa nova ferramenta, precisamos retirar o dado de dentro da fun√ß√£o j√° que o tipo do retorno dela √© `IO String`, ou seja, al√©m de causar efeito colateral retirando um dado do mundo real, ela ainda retorna esse dado para a gente! Para retirar o dado de dentro do `IO String` e transforma-lo somente em uma `String`, n√≥s iremos usar o "operador" `<-` de vincula√ß√£o de vari√°vel. Lembrando que esse operador s√≥ est√° dispon√≠vel na nota√ß√£o `do`.

```idris
main : IO ()
main = do 
  putStrLn "Digite seu nome: "
  -- pegamos a linha e colocamos ela com o nome de `nome` :D
  nome <- getLine
  putStrLn "Bem vindo, \{nome}"
```

A diferen√ßa fundamental entre `let` e `<-` √© que o `<-` remove o valor de dentro do `IO`, ent√£o ele s√≥ funciona com fun√ß√µes que retornam IO, como `getLine`. J√° no let, podemos colocar qualquer valor.

Exercicios:
- 4.1 Fa√ßa um programa que pergunte a idade da pessoa e a multiplica por dois;
- 4.2 Fa√ßa um programa que calcule o resultado da fun√ß√£o fatorial de um n√∫mero que uma pessoa inserir.

Dicas:
- 4.1 Use `cast`;
- 4.2 Use a fun√ß√£o que fizemos nos cap√≠tulos passados com `cast`.

## 5.4 Fun√ß√µes e pure

Podemos separar nossas opera√ß√µes de IO em fun√ß√µes e ao inv√©s de retornar `()` sempre, podemos retornar o tipo que quisermos. Al√©m disso, podemos 
utilizar a fun√ß√£o `pure` para "elevar" um valor normal a um IO exemplo `pure 3` que √© do tipo `IO Int`:

```
perguntar : IO Int 
perguntar = do 
  putStrLn "Digite um n√∫mero: "
  res <- getLine 
  pure (cast res) -- Transformamos a String res em Int e encapsulamos com `IO` usando pure

main : IO ()
main = do
  putStrLn "Vamos calcular a soma de dois n√∫meros!"
  primeiro <- perguntar
  segundo  <- perguntar
  print (primeiro + segundo)
```

E essa maior que faz um loop utilizando um loop infinito.

```
-- Essa fun√ß√£o conta de 1 em 1 at√© a pessoa digitar n
continuar : IO Int 
continuar = do 
  putStrLn "Gostaria de contar mais 1? [s\\n]"
  resposta <- getLine
  if resposta == "s"
    then do -- Caso seja sim ele vai recursivamente contar
      valor <- continuar -- Vamos fazer recursivo caso diga sim
      pure (valor + 1)   -- Somamos um no valor que retornar 
    else do pure 0 -- caso seja outro (ou "n") ele retorna 0

main : IO ()
main = do 
  res <- continuar 
  putStrLn "Voce contou at√©: \{show res}"
```

<a align="end" href="https://github.com/felipegchi/Idris2Noobs/blob/main/1.Introducao/6.algebraic.md">
 PROXIMO
</a> 
